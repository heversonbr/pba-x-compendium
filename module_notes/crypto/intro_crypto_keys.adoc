:doctype: book
:toc:
:toclevels: 3


= Cryptographic keys


== Encoding

Computers work using binary data (long strings of 0s and 1s).
But these raw binary strings are very hard for humans to read, write, or share without making mistakes.
To solve this we use encoding, a way to represent binary data in a format that is more readable and manageable for humans.

Common Encoding Types in Cryptography & Blockchains

* Hexadecimal (Base16)
** Widely used to represent hashes and keys in blockchains and cryptography.
** Uses 16 characters (0-9 and A-F) to represent binary data in a compact, readable way.

// this is an example block in asciidoc
.A SHA-256 hash looks like
[example]
3a3f8b8d65e6a6b7f3e9c2f4a7e5b6d4e3a3f9gha6e7c3d4a5f3b2e1d0a8c9b7f6

* Base64 (General Purpose, Not Often Used in Bitcoin)
** Very compact but can include confusing characters like +, /, and =.
** Extremely useful in other contexts where compact binary-to-text encoding is needed.

Examples:  sending images or attachments in emails (MIME format), embedding small images in HTML or CSS as data:image/png;base64

* Base58 (Used for Bitcoin Addresses)
** Bitcoin addresses are encoded in Base58 to make them:
*** Shorter than hexadecimal
*** Easier for humans to read by removing similar-looking characters, it excludes: 0 (zero), O (capital o), I (capital i), and l (lowercase L)

.Bitcoin address looks like 
[example]
1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa

*Take-away*:

Why Encoding Matters

- Human readability: Easier to write down, share, and verify.
- Error reduction: Base58 specifically avoids characters that are commonly misread.
- Data integrity: Encoded strings can still be verified cryptographically even if they are human-friendly.


==  Mnemonics

The BIP-39 standard is a mnemonic system specifically designed for creating and recovering cryptographic keys in a human-readable way.
A mnemonic system helps people remember or record complex information more easily.

BIP-39 stands for Bitcoin Improvement Proposal 39.
It defines:
- How to create mnemonic phrases (like the 12, 18, or 24-word passphrases).
- How to convert those phrases into a cryptographic seed that can generate private keys and addresses.

// example block asciidoc
.a BIP-39 12-word seed
[example]
abandon ability able about above absent absorb abstract absurd abuse access accident

Substrate uses the dictionary of the `BIP39` standard.


== Address Format

In the context of cryptography, an address is essentially a public key.
In cryptocurrencies when talk about keys, usually we are talking about an address.

Addresses also include error check machanisms like checksum.
It is a simple however efficient way of checking if there was an error while copying or sendind an address information.
(if a single bit is wrong, the checksum will inform that the address is invalid).

Polkadot uses a specific address format, called SS58 which uses Base68 encoding and adds 2 bytes at the beginning of the address
to indicate the network. It also includes 2 bytes of checksum at the end.
SS58 Address format is designed keeping the multichain nature of Polkadot in mind.

You can use https://polkadot.subscan.io/tools/format_transform[format-transform] tool to check the account address on the other chains in the Polkadot ecosystem.
There has been a significant debate within Polkadot ecosystem to unify the address format across chains.
You can see the discussion https://forum.polkadot.network/t/unifying-polkadot-ecosystem-address-format/10042[here].

== Account Derivation Methods

Starting Point: Mnemonic Phrase, this is our master seed.

From this single seed, you can generate multiple accounts (each with their own public/private key pairs).
This process is called *Hierarchical Deterministic (HD) Wallet Derivation.
So, Key derivation allows one to derive (virtually limitless) child keys from one "parent".

*Why do we need account derivation?*

- You don’t need a new mnemonic every time you want a new account.
- You can generate unlimited accounts from one passphrase.
-  All accounts can be recovered from the same seed phrase.
- Keeps backup simple — one phrase to secure everything.

*How It Works ?*

. The 12-word phrase is converted into a master seed (a big random number).
. The seed generates the first private key (root key).
. Using derivation paths, you can systematically generate a new public/private keypair.
. Each Account is Unique: different keys, different addresses — but all are mathematically connected to the same mnemonic root

// example block
.Each step is a new account (new public/private keypair).
----
Account 0: m/44'/0'/0'/0/0
Account 1: m/44'/0'/0'/0/1
Account 2: m/44'/0'/0'/0/2
----

*Types*

There are two types of key derivation: Hard and Soft keys deivation.

* *Soft* (Non-Hardened) derivation:
** Allows public key derivation using a parent public key.
** You can derive child public keys from the parent public key alone (no need for the private key).
** You cannot generate a child private key only with the parent public key.
** You can derive BOTH child public and private keys from the parent private key.
** Weakness: If someone has parent public key + any child private key → they can compute the parent private key.

* *Hard* (hardnened) derivation:
** You ALWAYS need the parent private key to derive anything.
** From parent private key → can derive both child private keys and child public keys.
** From parent public key → cannot derive anything (not even child public keys).
** Safer: Even if someone has a child private key and the parent public key → they cannot compute the parent private key.

*Use cases*
   
*Soft Derivation* : Convenience & Public Monitoring
- Watch-Only Wallets (Public View Wallets): You want to monitor incoming transactions without having access to private keys. Ex: Payment gateways, Block explorers, 
- Lightweight Clients: Mobile or web wallets that want to generate public addresses quickly and safely.
- Payment Servers / POS Systems: A point-of-sale system that needs to generate fresh addresses for each customer, The POS system can derive child public keys without ever handling private keys.

*Hard Derivation* : Security & Privacy Protection 
- Securing Master Private Keys: When you want to make sure that if a child private key is exposed, the master private key is still safe.
- Account Separation in Multi-Account Wallets: Different accounts for different users or purposes.
- Cold Storage Setups: Cold wallets for long-term storage. ensures that even if a receiving address private key is accidentally exposed, the whole wallet seed and other accounts are still safe.
- Multi-Signature Wallets (Partially Hardened): Wallets where multiple parties must sign transactions, ensure that shared public keys don’t leak sensitive structure or parent keys.


== Activity: A practical example of hard and soft key derivation 

An example and activity, we use Polkadot JS Extension as it provides ability to create and derive accounts using a mnemonic phrase.
Note: https://polkadot.js.org/extension/[Polkadot JS Extension] is for developers only. 
If you are a developer and would like to explore the Polkadot account generation process, check the `Subkey` tool. 

The article mentioned in the video:  "How likely is it that someone could guess your Bitcoin private key?"

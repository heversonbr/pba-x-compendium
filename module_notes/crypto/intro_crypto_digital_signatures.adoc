:doctype: book
:toc:
:toclevels: 3


= Digital Signatures

== Properties

- ensures authenticity and integrity of digital communication, without reveling the private key. 
- authenticity: the message originates from the sender that claims to be the sender
- integrity: the message was not altered during communication.

Signature libraries should expose the following basic functions:

- `generate_key(r) -> sk` : generate a secret key (sk) from some 'r' input.
- `public_key(sk) -> pk ` : generate a public key (pk) from sk.
- `sign(sk, m) -> sig` : takes sk and a message 'm' and returns a digital signature.
- `verify(pk, m, sig) -> bool` : takes sk, m, and a signature and returns true if the signature is valid. false otherwise.

Note that, is often more practical to sign the hash of a message, instead of the full message, therefore
sign and verify functions usually have the following forms instead:

- `sign(sk, H(m)) -> sib`
- `verify(pk, H(m), sig) -> bool`

Other properties of signatures:

* Non-repudiation: Yes, The sender cannot deny sending the message.
* Confidentiality: No, weak footnote:[We say “weak confidentiality” instead of “no confidentiality” to acknowledge that while digital signatures don’t provide real secrecy, they might, in very specific or indirect ways, limit exposure slightly. But it’s never enough to rely on for actual security of secret information.] or absent because:
** The signature process does not hide the message.
** The signed message remains readable by everyone.
** The purpose is to verify authenticity, not to conceal content.


== Digital signatures in Practice

As just mentioned, in practice only the hash of a message is required to sign the message and verify the signature.
One challenge that signatures must address are replay attacks.
In a replay attack, the attacker intecepts the message and resends it to manipulate the system.
For instance, imagine that an attacker intercepts a message that transfer some amount of assets from account A to account B.
It replays (resends) this message multiple times in order to make multiple unauthorized transfers.

To prevent replay attacks, digital signatures usually implement additional information, such as nonces, timestamps or context information.

- *Nonces* (Number used once):
A unique, random value added to each message.
Prevents duplication since the server checks whether the nonce has been used before.

- *Timestamps*:
Ensure the message is only valid within a specific time window.
Prevents old messages from being reused.

- *Context Information*:
includes any data that defines the environment or circumstances of a transaction.
Examples: session ID, timestamp, sender ID, location, protocol version, etc.
For instance, we can bind signatures to specific sessions, so they cannot be reused in a different context.


== Digital Signatures in Action

This section shows a video of showing a transaction being sent from user A to B,
the highlight of this example is to show the incremental nonce added to the transaction by the wallet
as well as the timestamp that defined the lifetime that is added by the call.
Both are measure of preventing replay attacks.


== Digital Signatures - Elliptic curves

There are several algorithms used to create digital signatures, each one with its strengths and use cases.
Some of the most prominent include:

=== ECDSA (Elliptic Curve Digital Signature Algorithm)

ECDSA is a widely used digital signature scheme based on elliptic curve cryptography (ECC).
It provides a way to verify the authenticity and integrity of digital messages or data.

Efficiency: ECDSA offers strong security with smaller key sizes compared to RSA, making it faster and more suitable for constrained environments.
Non-Deterministic: ECDSA relies on generating a random nonce for each signature; if the nonce is reused or predictable, it can compromise the private key.
Usage: Common in Bitcoin, Ethereum, TLS, and many cryptographic protocols.

Limitations of ECDSA:

* Nonce Sensitivity:
** Biggest Weakness: ECDSA critically depends on using a unique, high-quality random nonce (per signature).
** Risk: If the same nonce is reused, or if the nonce is partially predictable, the private key can be fully recovered.
** Example: Several real-world attacks (including on Bitcoin wallets) have exploited poor nonce generation to steal private keys.
+
*  Non-Deterministic by Default:
** ECDSA traditionally relies on external randomness for each signature, which can introduce security risks if the random number generator is flawed.
** Deterministic variants (like RFC 6979) have been proposed but are not always implemented.
+
* Complex Implementation
** ECDSA is more mathematically complex than some alternatives like EdDSA, making it harder to implement securely and efficiently.
** More prone to side-channel attacks if not carefully designed.
+
* Slower than Modern Alternatives:
** ECDSA is generally slower than Ed25519, both in signing and verifying, especially on constrained devices.
+
* Larger Signature Size Compared to Ed25519:
** While smaller than RSA, ECDSA signatures are typically larger and slower to verify than Ed25519, which has become a more preferred standard in modern cryptography.


=== Ed25519 (Edwards-curve Digital Signature Algorithm)

Ed25519 is a high-performance, modern digital signature algorithm that implements the Edwards-curve Digital Signature Algorithm using the Edwards curve Ed25519.

* It is designed to provide fast, secure, and compact signatures with strong resistance to common cryptographic attacks.
* Deterministic Signatures: Eliminates nonce-related vulnerabilities by generating nonces deterministically from the private key and message.
* High Performance: Faster signing and verification compared to ECDSA, especially on low-power or embedded devices.
* Compact Size: Public keys are 32 bytes and signatures are 64 bytes, which saves storage and bandwidth.
* Side-Channel Resistance: Designed to minimize the risk of timing and side-channel attacks.
* Widely Adopted: Used in modern systems like SSH, TLS 1.3, cryptocurrencies (like Monero), and secure messaging apps
* Ed25519 is inspired by Schnorr signatures but is a more advanced and standardized form, adapted to use modern elliptic curve techniques and deterministic signing.

Limitations of Ed25519:

* Curve Rigidity
** Ed25519 uses a fixed curve (the Edwards form of Curve25519).
** Unlike ECDSA, which can work over various NIST curves, Ed25519 offers no flexibility to choose different elliptic curves.
* Limited Support for Advanced Features
** ECDSA can be more easily adapted to schemes like threshold signatures or certain multi-signature protocols.
** Ed25519 requires additional construction (like MuSig2 or other schemes) for efficient multi-signature set	


=== Sr25519 (Schnorrkel/Ristretto x25519):

Sr25519 is a modern digital signature scheme based on Schnorr signatures using the Ristretto group, which is derived from Curve25519.

It is specifically designed for use in modern blockchain platforms like Polkadot and Substrate.

- Based on Schnorr Signatures: Offers simple security proofs and strong resistance to common cryptographic attacks.
- Uses Ristretto: This solves the cofactor issues of elliptic curves and provides a clean, prime-order group for better cryptographic properties.
- Deterministic Signatures: Like Ed25519, Sr25519 uses deterministic nonce generation, avoiding the nonce reuse problems of ECDSA.
- Batch Verification: Supports efficient batch signature verification, improving performance when validating many signatures at once.
- Native Support for  multi-signature schemes, zero-knowledge-friendly constructs.
- Optimized for Blockchain: Specifically built for high-performance, scalable blockchain systems.

Limitations of Sr25519

- Limited Adoption Outside Specific Ecosystems:  Sr25519 is currently most widely used in the Polkadot ecosystem. Broader adoption in standards like TLS, SSH, or legacy systems is still very limited.
- Complexity Compared to Ed25519: The Ristretto abstraction adds a layer of complexity that makes Sr25519 slightly harder to understand and implement from scratch compared to Ed25519.
- Less Mature Tooling: Although rapidly improving, Sr25519 has less mature libraries and tooling across all platforms compared to Ed25519 or ECDSA. Integration in multi-language environments is still catching up.
- Larger Signature Size Than ECDSA: Sr25519 signatures are similar in size to Ed25519 (64 bytes), which is larger than the smallest possible ECDSA signatures when using certain curves and optimizations.


=== Summary table

[cols="1,1,1,1", options="header"]
|===
| Feature | ECDSA | Ed25519 | Sr25519

| Cryptographic Basis
| Elliptic Curve Digital Signature Algorithm (ECDSA)
| Edwards-curve Digital Signature Algorithm (EdDSA)
| Schnorr Signatures over Ristretto (based on Curve25519)

| Deterministic Signatures
| No (requires secure random nonce)
| Yes (deterministic nonce from message and private key)
| Yes (deterministic nonce from message and private key)

| Nonce Sensitivity
| High (reuse can leak private key)
| Low (deterministic nonce generation)
| Low (deterministic nonce generation)

| Key Size
| Typically 32 bytes (256-bit curve)
| 32 bytes
| 32 bytes

| Signature Size
| Variable, often ~70 bytes
| 64 bytes
| 64 bytes

| Performance
| Moderate (slower than Ed25519/Sr25519)
| Very fast (optimized for speed)
| Fast, with efficient batch verification

| Batch Verification
| Less efficient
| Supported
| Highly efficient

| Multi-signature Support
| Requires custom protocols
| Possible but complex
| Natively supported, more efficient

| Side-Channel Resistance
| Prone if not carefully implemented
| Designed to resist side-channel attacks
| Designed to resist side-channel attacks

| Ecosystem Adoption
| Widely used (Bitcoin, Ethereum, TLS, legacy systems)
| Widely used (SSH, TLS 1.3, modern systems)
| Primarily in Polkadot, Substrate, emerging adoption

| Tooling & Libraries
| Mature, broadly available
| Mature, broadly available
| Growing, but less mature across all platforms

| Flexibility of Curve Choice
| Multiple curves (e.g., secp256k1, P-256)
| Fixed to Ed25519
| Fixed to Ristretto derived from Curve25519

| Use Cases
| Traditional financial systems, blockchain, secure communication
| Modern secure systems, SSH, cryptocurrencies, messaging apps
| Blockchain (Polkadot, Substrate), scalable decentralized systems

|===



== Multi-Signatures

Multi-signature (multi-sig) is a cryptographic technique that requires multiple parties to jointly authorize a transaction or message.
Instead of relying on a single private key, a group of keys must collaborate to produce a valid signature.

- A multi-sig account is controlled by a set of individuals that hold each their own pub/priv key pairs.
- The multi-sig account have only a public key, but not a private key.
- Funds can be sent to the public address of the multi-sig account and they can only be moved out if there is a
preset threshold of signatures received.

[example]
A “2-of-3” multi-sig wallet requires any 2 out of 3 participants to approve a transaction before it can be executed.

*Advantages*

- Enhanced Security: Reduces risk of single key compromise.
- Shared Control: Useful for organizations, families, or teams to manage joint assets.
- Trustless Collaboration: No need for a central authority; signatures can be verified collectively.
- Resistance to Theft: Even if one key is stolen, funds or access remain secure.

*Use Cases*
- Cryptocurrency Wallets: Bitcoin, Ethereum, Polkadot (shared wallets with multiple owners).
- Decentralized Governance: Multi-party control of treasury funds.
- Escrow Services: Conditional transactions requiring multiple approvals.
- Cross-Chain Bridges: Secure multi-party authorization for asset transfers between blockchains.
- Enterprise Access Control: Secure corporate signing processes.

*Limitations*

- Complexity: More complicated setup and key management.
- Higher Transaction Fees: Multi-sig transactions can be larger and more expensive on-chain (notably in Bitcoin).
- Limited Privacy: Traditional multi-sig (like Bitcoin’s) can reveal the number of participants and threshold on the blockchain.
- Interoperability: Not all wallets, smart contracts, or protocols natively support multi-sig.
- Recovery Challenges: Loss of multiple keys can permanently lock access.

*Anonimity/Privacy*

The anonymity of signers in a multi-signature group depends heavily on the type of multi-sig scheme used.
It is possible to check each of the members of a multi-sig group has signed a message.
But there are some multi-sig schemes that preserv the anonimity of the signers. For instance Ring signatures preserve the anonumity.

* Traditional Multi-Sig (e.g., Bitcoin P2SH)
** Visibility: The multi-sig structure is publicly visible on the blockchain.
** Low anonymity – signers and signing policies are exposed.

* MuSig and MuSig2 (Schnorr-based Multi-Sig)
** All participant keys are aggregated into a single public key.
** The resulting signature is indistinguishable from a single-signer signature.
** High anonymity – no information about the number of participants or individual signers is revealed.

* Threshold Signature Schemes (TSS)
** TSS allows a group to jointly compute a signature without ever revealing individual key shares.
** To outside observers, the signature looks like it was produced by a single key.
** Strong anonymity – individual signers remain hidden, no signer metadata is leaked

* Smart Contract Multi-Sig (e.g., Gnosis Safe on Ethereum)
** The contract publicly records which keys are authorized and which keys signed each transaction.
** Low to medium anonymity – signer identities and approval history are usually on-chain.

=== Quick comparation table

[cols="1,1,1,1,1", options="header"]
|===
| Scheme | Signer Anonymity | Requires Group Manager | Notes | Common Use

| Aggregated Signatures
| Low (unless using MuSig2)
| No
| Compress multiple signatures into one
| Blockchain consensus, BLS signatures

| Ring Signatures
| Strong
| No
| Untraceable, signer hidden within group
| Privacy coins (e.g., Monero), anonymous reporting

| Group Signatures
| Conditional
| Yes (optional traceability)
| Anonymity with controlled accountability
| Corporate voting, permissioned blockchains

| Threshold Signatures
| Varies (can be anonymous)
| No
| Distributed signing, no single key exposure
| Custodial wallets, distributed ledgers, cross-chain bridges

|===


*Tools and Protocols*:

* Bitcoin:
** Native P2SH (Pay-to-Script-Hash) multi-sig
** MuSig and MuSig2 (next-gen Schnorr-based multi-sig with privacy and efficiency improvements)
* Ethereum:
** Gnosis Safe
** Smart contract multi-sig wallet, industry standard
* Polkadot/Substrate:
** Native multi-sig support via Sr25519
* Cardano:
** Native multi-sig scripts
* General:
** TSS (Threshold Signature Schemes): Used in Fireblocks, ZenGo, and other wallet infrastructures for keyless multi-party signatures.
** MuSig2 (Bitcoin, Schnorr-based): Efficient, private, and scalable multi-sig protocol.


== Multi-Signature Accounts in Action

For enterprise grade management of multi-sig account some tools are available like:

- Talisman Signet
- Multix from chainsafe

This section is mostly a video example of using Polkadot-JS for showing multi-sigs in action.

In `polkadot-js` we can add addresses in our contacts (address book).
Then, we can select add a multi sig account and select the addresses for this account from our address book.
We set the threashold, and the name for the group.
The example shows the use of the multi-sig using Passeo testnet , to simulate the use to sending some assets with a multi-sig account.

== References:

- https://wiki.polkadot.network/learn/learn-cryptography/
- https://en.wikipedia.org/wiki/Digital_signature
- https://cqi.inf.usi.ch/blog/four.html
- https://polkadot-blockchain-academy.github.io/pba-content/singapore-2024/syllabus/1-Cryptography/6-Advanced_Signatures-slides.html#/4





	

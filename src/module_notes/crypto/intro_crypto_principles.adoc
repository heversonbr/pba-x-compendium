:doctype: book
:toc:
:toclevels: 3

= Cryptography Principles

== Cryptography overview

Cryptography brief historic and current use of cryptography.
In the past, the design of cryptography protocols used to be more based on heuristics (relying on intuition)
and the methods we designed mostly in an ad hoc fashion. Nowadays a more scientific approach
is used, we design methods with well defined models that come with mathematical proofs of security.
The main idea is that the methods are guaranteed to be secure in the specified model unless some underlaying assumption is false.

Cryptography provides a collection of tools for secure interaction in the presence of adversaries.

- public key encryption
- digital signatures
- zero knowledge proofs
- anonymous digital cache
- multi-party computation

== Secure communication

A user `A` wants to send a secure message `m` to user `B`.

In cryptography we need to specify what secure means in this case, in other words we need to
describe which security graranties are desired. We need that because we do not want to start
designing clever algorithms without knowing the exact goals we want to achieve.

In this case security communication could means many things, for instance:

- Confidentiality:  the message `m` must remain secret (only the recipient must read).
- Authenticity: the recipient `B` is sure about the origin of message `m` is the sender `A`, and not anybody else.
- Non-repudiation: `A` cannot deny the fact that it sent the message `m` if he/she did it. 
- (data) Integrity: if message `m` is tampered (modified/manipulated) with, if will be easily noticed.
- (data) Availability: not always considered as a cryptographic guarantee, but we want the data to be available to access.
- (data) Verifiability: in some contexts, we want to prove that possibly sensitive data satisfy some conditions/properties without revealing the information (zero knowledge proofs).

After defining these goals we have to think about how to achieve these goals.
This envolves typically specifying two points:

* Define the base layer we will start with:
* Specify the schemes or methods that make use of this base layer to achieve the goals.

In the case of the previous example of secure communication,
we can for instance, first start by defining an insecure communication channel over the internet to allow `A` sending messages to `B`.
Then, we speficy the methods that may include encryption schemes, digital signatures and other tools that will
turn this insecure communication into a secure channel that achieve the goals that we described in the begining.


=== Secure communication: an example

How A sends a secure message to B if the communication channel (cc) is insecure.

[example]
`A`  ------cc----->  `B`

First scenario, `A` knows `B` and both meet personally to exchange copies of a key for a specific lock,
then `A` uses this lock to lock the message inside and send the box to `B`.
`A` knows that only `B` can have a key to open that lock. So the message is secured.

Now, lets assume that `A` and `B` can not meet each other, or they do not know each other.
How can they exchange the message securely now ?
`A` can actually get a box and send an unbraekable lock to `B`, `B` in his turn gets the lock of `A` 
and puts his own unbreakable lock inside a box and send back to `A`.
`A` receives the lock of `B` which it can remove from the box, and use the lock of `B` to lock the secure message
inside a box and send back to `B`, now locked with the lock of `B`, so only `B` can open and read it.

This example shows a basic and simplified example of exchanging cryptographic encryption keys.

== Kefckhoff's Principle:

Created by Auguste Kerckhoffs in the 19th century.

The Kerckhoffs' principle states that the security of a cryptographic system should not depend
on the secrecy of the algorithm, but rather on the secrecy of the cryptographic key.
The system should remain secure even if the algorith is publicly known, with the key being the only
confidential element.

In other words:
[quote]
----
A cryptosystem should be secure even if everything about the system is public knowledge, EXCEPT THE KEY.
----

We should not rely in the secrecy of the method, which is known as security by obscurity.
We should not hope that no one is able or capable of figuring it out.

Reasons for that:

- It is easier to store a short key than the description of the method.
- if we loose a key it is easier to replace for a new one, than creating a new method.
- having the method public, allows for the community to work together to validate the method as a secure method.

Following Kerckhoffs principle allows for rigorous testing and analysis, ensuring the security of the method or system that uses it.

Therefore, the power of cryptography methods relies on good choice of keys.
Keys that are random and unpredictable are harder to crack.
We measure the level of randomness of a key via entropy (the amount of non-redundant information cointained, less random lower entropy).
Choosing keys from high entropy distributions, adversaries will have lower probability of obtaining them.

== Take-away

- Criptography is today a core science for building secure and highly complex decentralized systems. 
- We want to build systems with strong secutiry guarantess, with the smallest amount of assumptions as possible,
and at the same time ensuring high performances. And this is an important trade-off.
- Understanding the basic primitives of cryptographic tools are core to achieve that.


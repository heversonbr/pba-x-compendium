:doctype: book
:toc:
:toclevels: 3

= Hashing and Encryption

== Hash functions

Hash functions are one of the fundamental building blocks of cryptography.
A hash function is a one-way function that creates a compact representation of input data.
No matter how large the input, the output—called the hash—is of fixed size.
In other words, hash functions map an unbounded input space to a bounded output space.
They are designed to be fast to compute in the forward direction.
However, reversing the process—recovering the input from the hash—is computationally infeasible.
Good hash functions are also collision-resistant.
That means it is very hard to find two different inputs that produce the same hash.
At their core, hash functions are used to uniquely identify data.


=== Hash Function in Action

SHA-256 is a widely used hash function that belongs to the SHA-2 (Secure Hash Algorithm 2) family.
SHA-2 is a collection of cryptographic hash functions designed for secure data hashing.

To see SHA-256 in action, we will use a visual demo available online.
The demo is hosted at:

 https://guggero.github.io/blockchain-demo/#!/hash

It is an interactive tool that helps you understand how hash functions behave with different inputs.
This version is a complete rewrite of Anders Brownworth's original Blockchain Demo.
While the underlying code has changed, the core educational idea from Brownworth's excellent demo video remains.

Try changing the input data in the demo and observe how the hash output changes.
Even small changes in the input produce completely different hashes.
This property is known as the avalanche effect.
It demonstrates how hash functions are sensitive to input and useful for ensuring data integrity.


=== Properties of Hash Funtions

* accept unbounded size input
* map to a bounded fixed size output
* speed, the function must be quick to compute
* *an one-way function (pre-image resistence)*:
** given a hash value, it should be computationally infeasible to find any input that produces that hash.
** stops attackers from recovering the original input from the hash.
** protects against reverse-engineering hashed passwords.
* *second Pre-Image Resistance*:
** given a specific input and its hash, it should be computationally infeasible to find a different input that produces the same hash.
** this is about modifying a known input without changing its hash.
** used for Document tampering, signature forgery
* *collision resistence*: An attacker is free to find any two completely different files (arbitrary inputs) that hash to the same value.
** this is especially dangerous for digital signatures, The attacker gets you to sign a benign file.
** the famous SHA-1 collision attack (Google’s SHAttered project in 2017)


*Key differences*: Freedom of Choice
- Pre-image resistance: The attacker is stuck with a specific hash.
- Second pre-image resistance: The attacker is stuck with a specific input.
- Collision resistance: The attacker is free to choose everything.

Weak collision resistance, which is also called second preimage resistance.
Strong collision resistance, is also known as Collision resistence.


==== Quick summary

[cols="1,3,3", options="header"]
|===
| Hash Property | Attack Example | Real-World Risk

| Pre-Image Resistance
| Recover original input from a known hash (e.g., cracking a hashed password)
| Hash reversal (password recovery, leaking sensitive data)

| Second Pre-Image Resistance 
| Given a signed document, find a *different* document with the same hash
| Document tampering (targeted forgery of signed documents)

| Collision Resistance
| Create two distinct documents that hash to the same value before signing
| Signature forgery (swap benign document with malicious one after signing)
|===



=== Cryptographic vs Non-cryptographic Hash functions


- *Cryptographic hash functions*:
  provide security guarantess and are supposed to be collision resistent
  slower than non-cryptographic ones, but used when security is a primary concern
+
- *Non-cryptographic hash functions*:
  much faster, but weeker guarantees,
  used in file retrival and indexing, can also be used when users/nodes are known to NOT be malicious. 

NOTE: It is important to rememnber that no hash function is fully collision resistant, there's always a possibility of a collusion given the fact that
the input domain is larger than the output range.
This is a fundamental concept known as the *Pigeonhole Principle*, which guarantees that collisions must exist for any hash function with a fixed output size.

*Why Collisions Are Inevitable*?

The rationale behind that:

----
The reason collisions must happen is based on basic math and logic.
A hash function takes inputs that can be infinitely large or very big.
But it produces outputs of fixed size, for example, 256 bits.
This means there are only a finite number of possible outputs—specifically, 2^256.
Since the input space is much larger than the output space, some inputs must share the same output.
This situation is known as a collision.
You can think of it like having 10 pigeonholes but 11 pigeons.
With more pigeons than holes, at least one hole must contain two pigeons.
Similarly, multiple inputs must map to the same hash output.
----

So, Collision resistance does not mean no collisions exist.

- Instead, it means it is computationally infeasible to find such collisions.
- In other words, finding a collision should require an impractical amount of time and resources (far beyond current computing capabilities).

If collisions become easy to find (like SHA-1 today), the hash function is considered broken for cryptographic use and should be replaced by stronger functions (SHA-256, SHA-3, etc.).


=== Hash Function: Applications

Hash functions also provide data integrity.
Even a single bit change in the input causes a completely different hash output.
This makes it easy to detect any tampering with the data.

Hash functions can also be used as commitment schemes.
A commitment scheme binds input data to a specific output, providing strong privacy guarantees.
This means the output hides all information about the input.
With a commitment scheme, you can prove you committed to some data without revealing it.

We will see commitment schemes in more detail later.


=== Take-away

- A hash function is one of the most fundamental building blocks in cryptography.
- Hash functions produce fixed-size outputs from inputs of any size.
- They are designed to be fast to compute and hard to reverse.
- Hash functions ensure data integrity by producing drastically different outputs for small input changes.
- They are essential for securing data and verifying identities.
- Hash functions play a critical role in blockchain technology to ensure transaction integrity and security.

== Commitment schemes

A commitment scheme is a cryptographic primitive that allows one to commit to a chosen value (or chosen statement) while keeping it hidden to others, with the ability to reveal the committed value later.

In other words, a commitment scheme is a way to "lock" a secret value.
It lets you commit to a value without revealing it right away.
Later, you can "open" the commitment to prove what the original value was.

So, it lets you:

* *Commit*: Lock in a value secretly (put it in the envelope).
* *Reveal*: Later, open the envelope to reveal the committed value.

And ensures two important properties:  

- **Hiding:** No one can guess the committed value before you reveal it.  
- **Binding:** You cannot change the value after committing.

Commitment schemes are like putting a message in a locked box.
You show the box to others but keep the message secret.
When ready, you open the box and reveal the message.
This helps in secure protocols where privacy and honesty matter.
Hash functions are often used to build commitment schemes.


=== How Hash Functions Implement Commitment

You can use a hash function to build a simple commitment scheme.

==== Commit Phase

- Choose a value `x` that you want to commit to.
- Pick a random value `r` (called a nonce) to keep it secure.
- Compute the commitment: `C = H(x | r)` where `|` means concatenation.
- Share `C` as your commitment. Keep `x` and `r` secret for now.

==== Reveal Phase

- When you're ready, reveal both `x` and `r`.
- Anyone can verify your commitment by checking:  
  `H(x | r) == C`
- If the values match, the commitment is valid.

==== Why It Works: Required Properties

- **Hiding:**  
  The random `r` hides `x`.  
  Without `r`, no one can guess `x` from `C`.  
  This assumes the hash behaves like a random oracle.

- **Binding:**  
  Because of collision resistance, you can't find other values `x'`, `r'`  
  such that `H(x' | r') == H(x | r) == C` unless they are the same as `x` and `r`.  
  This means you can't change your committed value later.

Commitment schemes built from hash functions are simple but powerful.
They are used in many cryptographic protocols to ensure fairness and privacy.


=== Real-World Use Cases

Commitment schemes are used in many real-world cryptographic systems.

- **Secure Auctions:**  
  Bidders commit to their bids in secret.  
  Later, they reveal the bids.  
  This prevents cheating or changing bids after seeing others.

- **Zero-Knowledge Proofs:**  
  Commitments hide secret values.  
  You can prove something is true without showing the secret itself.

- **Blockchain:**  
  Commitments are used to record transactions or states.  
  Once committed, the data cannot be changed without detection.

- **Digital Contracts:**  
  Parties can commit to contract terms before revealing them.  
  This adds fairness and prevents manipulation.

These use cases show how commitments provide both privacy and trust.





== Encryption: Symmetric vs Asymmetric

Encryption is the process of transforming readable data (plaintext) into an unreadable form (ciphertext) using a cryptographic key.
Only someone with the correct key can convert the ciphertext back into the original plaintext.

There are two main types of encryption: symmetric and asymmetric.

=== Symmetric Encryption

- Also called secret-key encryption.
- The same key is used for both encryption and decryption.
- Both the sender and receiver must share this key in advance.
- This can be difficult if the parties have never met or don't already trust each other.

Examples: ChaCha20, AES, DES, Blowfish, Twofish, Serpent

==== Guarantees

[options="header",cols="2"]
|===
| Provides | Does NOT provide

| Confidentiality (keeps data secret) | Integrity (detecting tampering)

| | Authenticity (proving who sent the message)

| | Non-repudiation (preventing denial of sending)
|===

=== Asymmetric Encryption

- Also called public-key encryption.
- Uses a key pair: one public, one private.
- The public key encrypts the data.
- Only the matching private key can decrypt it.
- The public key can be shared openly.
- The private key must be kept secret.

- Asymmetric encryption is more computationally expensive than symmetric.
- It is not ideal for encrypting large amounts of data.

A common use is secure key exchange.  
Two parties can exchange a symmetric key using asymmetric encryption.  
Then they switch to symmetric encryption for ongoing communication.  
This gives the speed of symmetric encryption with the security of asymmetric key setup.

Examples: RSA, ElGamal, Paillier

==== Guarantees

[options="header",cols="2"]
|===
| Provides | Does NOT provide

| Confidentiality (same as symmetric) | Integrity

| | Authenticity

| | Non-repudiation
|===


== Assymetric Encryption: Explained Example

Two breakthrough algorithms that allow secure communication between two parties without a shared secret:

- *RSA algorithm* (1977): Relies on number theory, specially in prime numbers and the difficulty of prime number factorization.
  It provides a public/private key pair which are really long numbers.
  Then if two parties want to communicate securely the first sends it public key to the other. Upon receipt the public key it uses the public key
  to encrypt the message, which that  only the owner of the public key can read the message.  And this is what we call assymetric cryptography and this is computationally expansive.

- *Diffie-Hellman key exchange algorithm* (1976/77):
it is a mathematical method of securely generating a symmetric cryptographic key over a public channel and was one of the first protocols as conceived by Ralph Merkle and named after Whitfield Diffie and Martin Hellman.

Let's see an example:


[example]
A and B want to exchange messages

*Parameters*:
These values are known to everyone (including attackers):

- p: A large prime number (modulus)
- g: A primitive root modulo p (called the base or generator)

For instance, p = 23, g = 5

* *Alice generates*:
** A secret random number a
** Computes A = g^a \mod p
** Sends A to Bob
*** Message from Alice to Bob: A = g^a mod p
* *Bob generates*:
** A secret random number b
** Computes B = g^b \mod p
** Sends B to Alice
*** Message from Bob to Alice: B = g^b mod p

* *Both compute the shared secret*:
** Alice receives B, computes: S = B^a \mod p = g^{ba} \mod p
** Bob receives A, computes: S = A^b \mod p = g^{ab} \mod p

Now both share the same secret S, without having sent it directly.


*Note*:

- The shared key is never sent, only derived.
- DH by itself provides key agreement, not encryption or authentication.
- It’s vulnerable to man-in-the-middle attacks unless combined with authentication (like in TLS).


== Take-away

- Encryption protects the confidentiality of sensitive data.
- There are two main types: symmetric and asymmetric encryption.
- Symmetric encryption is fast and efficient.
- But it requires both parties to share a secret key in advance.
- Asymmetric encryption solves the key exchange problem.
- It uses a public key to encrypt and a private key to decrypt.
- However, asymmetric encryption is much slower.
- In practice, both methods are often combined for secure and efficient communication.


== Read more

- https://en.wikipedia.org/wiki/Public-key_cryptography
- https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange
- https://cryptotools.net/rsagen
- https://polkadot-blockchain-academy.github.io/pba-content/singapore-2024/syllabus/1-Cryptography/4-Encryption-slides.html#/9

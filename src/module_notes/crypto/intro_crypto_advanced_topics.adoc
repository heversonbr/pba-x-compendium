:doctype: book
:toc:
:toclevels: 3


= Advanced Cryptography Topics

== Advanced Cryptography Primitives

We have previously seen that multi-sig schemes can be usefull to avoid single point of failures and
loss of keys of one or more accounts in a threshold multi-sig.
One inconvenient side of using multi-sig for this purpose is that we have to manage multiple accounts and their private keys.

There is another technique that helps us to preserve a single private key across multiple locations to avoid loss and failures.
That is Shamir secret sharing. 

=== Shamir secret sharing

Shamir’s Secret Sharing (SSS) is a cryptographic method invented by Adi Shamir in 1979.
It allows a secret (like a password or cryptographic key) to be split into multiple parts (shares).
Only a minimum number of those parts (a threshold) is needed to reconstruct the secret.
Less than that provides no information.
This technique is similar to erasure coding techniques.

It is based on polynomial interpolation over finite fields:

- Any k points uniquely determine a polynomial of degree k−1.
- Shares are points on a secret polynomial; the secret is the y-intercept.

*Benefits*

- High Security: No information is leaked unless the threshold is met.
- Redundancy: Shares can be distributed across multiple parties/locations to protect against data loss.
- Flexible Access Control: You can set custom thresholds (e.g., 3 out of 5 shares).

*Limitations*

- Requires Secure Distribution: Shares must be securely delivered to participants.
- No Share Renewal: Shares can’t be easily changed without redistributing new ones.
- No Protection Against Collusion: If the threshold is met by colluding parties, the secret is fully revealed.

*Common Use Cases*

- Cryptocurrency Wallet Recovery: Splitting wallet keys among trusted parties.
- Key Management Systems: Secure backup of encryption keys.
- Nuclear Launch Codes: Distributed control among several decision-makers.
- Secure Multi-Party Agreements: Joint authorization requirements.


==== Quick comparison table: SSS vs Multi-sig

[cols="1,1,1", options="header"]
|===
| Feature | SSS | Multi-Sig

| *Concept*
| Splits a single secret into parts
| Multiple parties each have their own key

| *Threshold*
| Reconstruct secret with k of n shares
| Requires k of n signatures to validate

| *Trust Model*
| Secret is fully revealed when threshold is met
| Secret is never reconstructed; signatures prove agreement

| *Risk*
| Colluding threshold can expose the secret
| Colluding threshold can approve transactions, but secret keys stay private

| *Use Case* 
| Key backup, disaster recovery
| Decentralized control (blockchains, wallets)
 
|===

== On-chain randomness - VRFs

Another interesting technique used in blockchains is VRF that is used to obtain private randomness, that is publicly verifiable.


=== VRF: Verifiable Random Function

A Verifiable Random Function (VRF) is like a cryptographic “random lottery” with proof.
It produces a random-looking output that is:
- Unique: Deterministic for the same input.
- Verifiable: Anyone can check that the output is correct without knowing the secret key.

It’s similar to a cryptographic hash function, but with proof of correctness tied to a private key.
Introduced by Micali, Rabin, and Vadhan in 1999, but gained significant use in blockchain protocols for leader selection and randomness generation.

*Interface*

- eval(sk,input) -> output
- sign(sk, input) -> signature
- verify(pk, input, signature) -> option output

The input can be a number that is known publicly and is agreed upon to be the input by all the participants.
By combining the input with the secret key (sk), which is known only to the secret key owner, and computing a hash of it results in an output that is pseudo-random.
This output can be revealed along with the signature later on, which can be verified by anyone by using their public key (pk).


*Output properties*:

- Output is a deterministic function of key and input, i.e. eval should be deterministic
- It should be pseudo-random
- But until the VRF proof is revealed, only the holder of the secret key knows the output
- Revealing output does not leak secret key

*Usage*

Choose input after key, then the key holder cannot influence the output.
The output then is effectively a random number known only to the key holder.
But they can later reveal it, by publishing the VRF proof (signature).

*Benefits*

- Unpredictability: Results can’t be predicted without the secret key.
- Verifiability: Others can independently verify the output using the public key.
- Fairness: Used to select participants randomly and fairly.

*Limitations*

- Requires Setup: Needs public/private key infrastructure.
- Deterministic: Given the same input and key, the output is always the same (can be a feature or a limitation).
- Complexity: More computationally intensive than simple random functions.

*Common Use Cases*

- Blockchain Leader Election: Example: Algorand uses VRFs to select block proposers randomly but verifiably.
- Random Number Generation: Secure lotteries, random selections where proof is required.
- Spam Prevention: Proof that a request is legitimate, used in anti-spam mechanisms.

*Example*

Players want to draw cards randomly and fairly without trusting each other or a central dealer.

. Players Agree on a Random Input
.. All players agree on a shared random number x (this can come from a shared source like a blockchain block hash or a collectively agreed event).
.. This ensures no single player can choose the input to bias the result.
. Player A Draws a Card Using a VRF
.. Player A has a secret key (sk_A) and a corresponding public key.
.. A uses their VRF function to compute: `y = \text{eval}(sk_A, x) \mod 52`
... `eval(sk_A, x)` : produces a pseudo-random but deterministic number tied to A’s secret key and input x.
... mod 52 : maps the number to one of the 52 cards in a deck.
.. *Result*: Player A’s card is uniquely determined by their secret key and the shared input x. No one can predict A’s card in advance.
. Player A Publishes the VRF Proof
.. Along with the card, A publishes the VRF proof (a special signature).
.. This proof allows all other players to verify:
... That A followed the correct process.
... That A didn’t cheat or pick a different card.

* The proof is verifiable using A’s public key and the shared input x.
* Players can check the card without knowing A’s secret key.


=== VRF Types

Some important variations of VRFs are:

. Threshold VRF:
+
A Threshold VRF allows a group of participants to jointly compute a VRF output without any single participant knowing the whole secret key.
+
- The VRF secret key is split (e.g., using Shamir’s Secret Sharing).
- A minimum number (threshold) of participants must cooperate to produce the VRF output and proof.
- No single party controls the randomness.
+
*Benefits*:
- Decentralized and fault-tolerant.
- Prevents bias or control by any single participant.
- Used in decentralized randomness beacons (like in Dfinity’s consensus).
+
. Ring VRF
+
A Ring VRF lets a participant generate a VRF output that is provably valid but anonymously linked to a group.
+
- The proof shows the result was produced by someone in a predefined group but doesn’t reveal who.
- Combines VRF with ring signatures (anonymous group signatures).
+
*Benefits*:
- Anonymity: Keeps the identity of the VRF generator hidden.
- Verifiability: Others can still verify the result came from a valid group member.
- Useful in privacy-preserving protocols, anonymous lotteries, or leader selection.


=== Takeaways

- *Fairness* comes from agreed input. No central dealer needed.
- *Randomness* comes from VRF evaluation. The combination of public input + secret key.
- *Security* comes from verifiable proof. A cannot lie about their draw.
- *Unpredictability* comes from the fact that results cannot be predicted without the secret key. Other players cannot predict or control the card A will draw.

== References

- https://chain.link/education-hub/verifiable-random-function-vrf
- https://docs.polkadot.com/polkadot-protocol/basics/randomness/#vrf
- https://eprint.iacr.org/2023/002.pdf

